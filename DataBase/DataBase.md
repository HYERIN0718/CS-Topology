<details>
<summary> 데이터베이스는 무엇인가요? </summary>
<div markdown="1">
  <br>
 
  데이터베이스는 일정한 규칙을 통해 구조화되어 저장되는 데이터의 모음입니다. <br> 
  
해당 데이터베이스를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)이라고 하며 
  데이터들은 특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있습니다. <br>
데이터베이스는 실시간 접근과 동시 공유가 가능합니다.

  
</div>
</details>

<details>
<summary> 데이터베이스의 장점은 무엇인가요? </summary>
<div markdown="1">
  <br>
 
- 데이터는 구조적으로 저장되므로 중복성이 제거됩니다.
- 데이터의 유효성을 검사할 수 있고 데이터베이스에 대한 액세스 제어를 제공합니다.
- 데이터 백업 및 복구를 제공합니다.
- 여러 사용자 인터페이스를 제공합니다.
  
</div>
</details>
  
  <details>
<summary> SQL은 무엇인가요? </summary>
<div markdown="1">
  <br>
 
SQL은 Structed Query Language로 DBMS에서 데이터를 관리하고 처리하기 위해 설계된 언어입니다.

- **DDL (데이터 정의 언어)** : 데이터의 구조를 정의하는 데 사용됩니다. 데이터베이스의 DDL 명령에 의해 수행 된 변경 사항이 자동커밋되고 영구적으로 저장됩니다.
- **DML (데이터 조작 언어)** : 데이터를 조작하는 데 사용됩니다. 자동 커밋되지 않으며 롤백 할 수 있습니다.
- **DCL (데이터 제어 언어)** : 데이터 액세스 권한 취소와 같이 데이터의 가시성을 제어하는 데 사용됩니다.
  
</div>
</details>

## ERD와 정규화
 <details>
<summary> 약한 엔터티와 강한 엔터티에 대해 설명해 보세요. </summary>
<div markdown="1">
  <br>
 
약한 엔터티는 혼자서 존재하지 못하고 특정 엔터티의 존재 여부에 따라 종속적인 것을 말합니다.  <br>
그리고 그 특정 엔터티는 강한 엔터티를 말합니다.
  
</div>
</details>

 <details>
<summary> ERD(Entity Relationship Diagram)를 사용하는 이유는 무엇인가요? </summary>
<div markdown="1">
  <br>
 
ERD는 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며 릴레이션 간의 관계들을 정의한 것입니다. <br>
시스템의 요구사항을 기반으로 작성되며 ERD를 기반으로 DB를 구축해야 설계도 역할이 됩니다.
  
</div>
</details>

 <details>
<summary> 정규화란 무엇인가요? </summary>
<div markdown="1">
  <br>
 데이터 무결성을 유지하기 위해 잘 정의 된 방식으로 테이블을 분할하는 프로세스입니다. <br>

데이터의 일관성을 유지하고, 자료의 중복성을 줄이고, 릴레이션을 독립적으로 표현하는 방법입니다.
릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 
저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리합니다.
  
</div>
</details>

 <details>
<summary> 정규화 과정에 대해 설명해보세요. </summary>
<div markdown="1">
  <br>
  
- **제1정규형** : 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자값(automic value)만으로 구성되도록 분해합니다.
- **제2정규형** : 제1정규형을 만족하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수종속될 수 있도록 분해합니다. 
- **제3정규형** : 제2정규형을 만족하고, 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않도록 분해합니다. 
  - 이행적 함수종속 : A→B, B→C 가 성립할 때 A→C가 성립되는 것 <br> 
- **BCNF정규형** : 제3정규형을 만족하고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 모든 결정자가 후보키가 되도록 분해합니다.
  
</div>
</details>

## 트랜잭션과 무결성
 <details>
<summary> 트랜잭션은 무엇이며 특징에 대해 설명해 보세요. </summary>
<div markdown="1">
  <br>

  트랜잭션이란 데이터베이스에서 논리적 기능을 수행하기 위한 작업의 단위를 말합니다.

- **원자성** : all or nothing. 트랜잭션과 관련된 일이 모두 수행되거나 혹은 모두 수행되지 않는 것을 의미합니다. 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 해당 작업이 모두 수행되지 않음을 보장합니다.
    
- **일관성** : 허용된 방식으로만 데이터를 변경해야한다는 것을 의미합니다. 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야합니다.
    
- **격리성** : 트랜잭션 수행 시 서로 끼어들지 못한다는 것을 의미합니다. 여러 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 합니다.
    
- **지속성** : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다는 것을 의미합니다. 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 하고, 이를 위해 체크섬, 저널링(파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영하기 전에 로그를 남기는 것), 롤백 등의 기능을 제공합니다.
  
</div>
</details>

 <details>
<summary> 무결성이란 무엇인가요? </summary>
<div markdown="1">
  <br>

  데이터의 정확성, 일관성, 유효성을 유지하는 것을 말하며, 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는 지에 대한 신뢰가 생깁니다.
  
</div>
</details>

## 데이터베이스의 종류
 <details>
<summary> DB의 종류에 대해서 설명하고 특징을 비교해 보세요. </summary>
<div markdown="1">
  <br>

 RDS(관계형 데이터베이스)는 대표적으로 MySQL이 있고, NoSQL(비관계형 데이터베이스)은 MongoDB가 있습니다.
- **MySQL** : 대부분의 운영체제와 호환되며 현재 가장 많이 사용되는 오픈소스 관계형 DBMS입니다. MySQL 코드는 대량의 트래픽을 처리할 수 있기 때문에 대규모 웹 사이트 및 웹 애플리케이션에 널리 사용됩니다.
  - 구조 : 레코드-테이블-데이터베이스
- **NoSQL** : 요구 사항에 맞게 최적화된 저장소 모델을 사용하고 데이터를 저장할 때 SQL문이 아닌 다른 프로그래밍 언어 및 구문을 사용합니다.
  - 구조 : 도큐먼트-컬렉션-데이터베이스  
</div>
</details>

## 인덱스
<summary> 인덱스의 구조형태에 대해서 설명해 보세요. </summary>
<div markdown="1">
  <br>

인덱스는 `B-트리`라는 자료구조로 이루어져 있습니다. 루트노드, 리프노드 그리고 루트노드와 리프노드 사이에 있는 브랜치노드로 나뉩니다. <br>
하나의 데이터를 찾는다고 하면 전체 테이블을 탐색하는 것이 아니라 데이터가 있을 법한 리프노드로 들어가면 데이터를 탐색합니다.
</div>
</details>

<details>
<summary> MySQL의 인덱스에 대해 설명해 보세요. </summary>
<div markdown="1">
  <br>

클러스터형 인덱스와 세컨더리 인덱스가 있으며, `클러스터형 인덱스`는 테이블마다 하나씩 설정할 수 있습니다. primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있습니다.
기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있습니다. <br><br>
`세컨더리 인덱스`는 create index.. 명령 기반으로 만들 수 있습니다. 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성합니다. 하나의 인덱스만 만들 것이라면 클러스터형 인덱스를 사용하는 것이 성능이 좋습니다.
</div>
</details>

 <details>
<summary> MongoDB의 인덱스에 대해 설명해 보세요. </summary>
<div markdown="1">
  <br>

도큐먼트를 만들면 자동으로 ObjectID가 형성되고, 해당 키가 기본키로 설정됩니다. <br>
세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있습니다.
</div>
</details>

 <details>
<summary> 인덱스를 최적화시키기 위한 방법을 아는대로 말해보세요. </summary>
<div markdown="1">
  <br>

1) 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 좋지 않습니다. 또한 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적입니다. 

2) 서비스에서 사용하는 객체의 깊이, 테이블의 양이 각각 다르기 때문에 서비스 특징에 따라 최적화 방법은 달라집니다. 따라서 늘 테스팅하는 것이 중요합니다. explain()함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화합니다.

3) 보통 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스는 [ 같음, 정렬, 다중 값, 카디널리티 ] 순으로 생성합니다.
</div>
</details>

## 조인
 <details>
<summary> 조인의 종류 4가지를 설명해 보세요. </summary>
<div markdown="1">
  <br>

1. `내부조인(inner join)` : 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 부분만 표기합니다.
2. `왼쪽조인(left join)` : 왼쪽테이블의 모든 행이 결과테이블에 표기됩니다.
3. `오른쪽조인(right join)` : 오른쪽 테이블의 모든 행이 결과 테이블에 표기됩니다.
4. `합집합 조인(full outer join)` : 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기합니다.
</div>
</details>
